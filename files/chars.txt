⁰	wrap the top same type items on the stack in an array
¹-⁹	context & input & program dependant variables. Defaults: //KEYW ¹²³⁴⁵⁶⁷⁸⁹
  ¹: Infinity
  ²: 256
  ³: 13
  ⁴: 64
  ⁵: 11
  ⁶: 12
  ⁷: 16
  ⁸: 128
  ⁹ - x: the program lines. ⁹ is the main program, ⁸ is the first helper, ⁷ - 2nd, ect.
  after those, come the inputs. So for a program with 1 helper line the 1st input would be ⁷, the second ⁶, ect.
  ¹-x: loop counters & stuff
    the current loops item is it's depth, and optionally the next superscript may be something. The ones before gat saved from previous loops, but only 1 value is accessible.
  if the above don't set a value, then this table shows each items value:
  
＋	add / join horizontally
  NN: add the numbers
    `７８＋` → 15
  aa: add the two items together horizontally
    `hello¶worl∙ ¶d!＋` → "hello  ¶worl d!"
－	subtract
（	start an array wrapping
  `１２（３４５）` → 1, 2, [3, 4, 5]
）	end array wrapping. （ can be implicit
［	loop
  N: repeat that many times (not pushing anything)
    `６７２［!＋Ｐ` → "7!¶6!"
  S: for each prefix
  A: for each prefix
］	close a loop, collecting the results and pushing them after, so `｛...］` would be a `.map` function
  `hello｛[ŗ]］∑` -> "[h][e][l][l][o]"
｛	loop
  N: repeat from 1 to that number, pushing the counter
    `３｛a×Ｐ` → "a¶aa¶aaa"
  S: for each character, pushing it
    `abc｛-ｐｐ` → "-a-b-c"
  A: for each item, pushing it
｝	close a loop
＜	less than
  NN: less than
    `４６＜` → 1
＞	greater than
  NN: greater than
    `２７＞` → 0
‰	
ø	push an empty art object
＾	power
    `Ａ３＾` -> 1000
◂	push "0123456789"
◂◂ push ["1234567890","qwertyuiop","asdfghjkl","zxcvbnm"]
←	
↑	
→	
↓	
↖	
↗	
↘	
↙	
↔	mirror horizontally
  S, A: mirror horizontally - reverse & swap chars as required
↕	mirror vertically
  S, a: mirror vertically - reverse vertically & swap chars as required
  N: floor divide by 2 + 1


printable ascii+¶: part of strings


┌	duplicate the item 2nd from top
┐	pop & remove an item
└	swap the two items below ToS
┘	put the 3nd item from top ontop
├	double increment / uppercase first letter
  N: increase by 2
    `７├` → 9
  S: uppercase the first letter of the first word
    `   hello, world!┤` → "   Hello, world!"
  A: vectorize
┤	double decrement
  N: decrease by 2
    `０┤` → -2
  S: cast to number
  A: put all the elements on the stack
┬	decode from base 10
  NN: convert x from base 10 to an array of digits of it in base y
┴	encode into base 10
  AN: convert the array, interpreted as base y, to a base 10 number
╴	previous input
╵	increment / sentence case
  N: increase by 1
  S: uppercase every letter after any of ".?!" and in the beginning
    `  hello, world! goodbye, world!╵` → "  Hello, world! Goodbye, world!"
  A: vectorize
╶	next input
╷	decrement / title case
  N: decrease by 1
  S: uppercase the first letter of every word
    `hello, world!╷` → "Hello, World!"
  A: vectorize
╋	overlap / replace
  sss: replace in the first the second with the third
  aaNN: overlap the 2nd art over the 1st at x;y using smartOverlap
×	repeat horizontally / prepend
  NN: multiply the numbers
    `６７×` → 42
  NA, AN, SN, NS: repeat horizontally
    `string３×` → "stringstringstring"
    `hello¶world!２×` → "hello hello ¶world!world!"
    `hello∙world!）２×` → ["hello hello ", "world!world!"]
  aa: reverse join / prepend //KEYW reverse add
    `World!∙Hello, ×` → "Hello, World!"
＊	repeat vertically / join string
  SN, NS: repeat the string vertically that many times
    `foo¶bar３＊` → "foo¶bar¶foo¶bar¶foo¶bar"
  NA, AN: multiply the array vertically that many times
    `a∙b）２＊` → ["a","b","a","b"]
  aNN: expand the ascii-art by the numbers
    `foo¶bar２３＊` → "ffoooo¶bbaarr¶ffoooo¶bbaarr¶ffoooo¶bbaarr"
  AS, SA: join the array with the string
    `3Ｒ:＊` → "1:2:3"
  SS: insert the second string between the firsts chars
    `2xy∙^＊` → "2^x^y"
÷	divide
  NN: divide the numbers
    `３∙４÷`
±	horizontal reverse / negate
  N: negate
  a: reverse horizontally
    `\abc/±` → "/cba\"
    `abc∙(def)）±` → ["  cba", ")fed("]
«	shift left
  N: shift left by 1 bit / multiply by 2
  S: put the first char at the end
  A: put the first item at the end
»	shift right
  N: shift right by 1 bit / floor divide by 2, storing the remainder
    `7»` → 3
  S: put the last char at the beginning
    `hello»` → "ohell"
  A: put the last item at the beginning
≤	
≥	
≡	equal
≠	not equal
Ａ	push 10
Ｂ	
Ｃ	push the ASCII characters (' '..'~')
Ｄ	deduplicate
Ｅ	
Ｆ	
Ｇ	
Ｈ	
Ｉ	
Ｊ	pop the first item / first line
Ｋ	pop the last item / last line
Ｌ	get length
    S, A, N: get length and pop the item
    a: get height, don't pop
Ｍ	
Ｎ	
Ｒ	range
  N: range from 1 to N, inclusive
  S: set the default background to the string
Ｓ	split on spaces
  S: split on spaces
Ｕ	uppercase/ceiling
  S: uppercase the string
  N: get the ceiling of the number
  A: vectorise
ｕ	lowercase/floor
  S: lowercase the string
  N: get the floor of the number
  A: vectorise
Ｖ	
Ｗ	while
  ｝: do..while(pop)
Ｚ	push the uppercase alphabet
ａ	
ｂ	
ｃ	convert to/from unicode
  N: convert from unicode codepoint
    `Ａ６×ｃ` → "<"
  S: convert to unicode codepoint
    `hｃ` → 104
    `helloｃ` → [104, 101, 108, 108, 111] (note that this only happens if length>1, be careful)
  A: convert to 2D array of codepoints
    `ab¶cｃ` → [[97, 98], [99, 0]]
ｄ	
ｅ	encase in a letter
`hello∙'ｅ` → "'hello'"
  SS: encase the 1st string in the 2nd
ｆ	
ｇ	
ｈ	
ｉ	
ｊ	remove first item / first line
ｋ	remove last item / last line
ｌ	get length
    S, A, N: get length, without popping
    a: get height, don't pop
ｍ	mold to length / reshape
    aN: reshape to the width of the number
ｎ	split into chunks / divmod
  NS, SN: split the string into chunks of length N, padding with spaces if necessary.
  NA, AN: split the array into arrays of length N. If there aren't enough items, just leave as-is.
    `１２３４５６）４ｎ` → [[1,2,3,4],[5,6]]
  NN: push the result of floor division and then modulo
  aa: overlap the two
ｒ	lowered range
  N: range from 0 to N-1, inclusive
  aS: set the arts background character to that
  a: center the art, preferring to go left
ｓ	split
  SS: split the 1st string on the 2nd
  SN: split the string on the number
ｖ	
ｗ	
ｘ	get the value of the variable X
ｙ	get the value of the variable Y
Ｘ	set the variable X to POP
Ｙ	set the variable Y to POP
ｚ	push the lowercase alphabet
//   newline   pop   disable auto output
// Ｏ	  x       x                       
// Ｐ	  x       x        x              
// Ｑ	  x                                
// Ｔ	  x                x                
// ｏ	          x                        
// ｐ	          x        x                
// ｑ	                                  
// ｔ	                   x               

Ｏ	output in a new line, popping the item
Ｐ	output in a new line, popping the item
Ｑ	output in a new line
Ｔ	output in a new line, disabling implicit output
ｏ	output in the current line, popping the item
ｐ	output in the current line, popping the item
ｑ	output in the current line
ｔ	output in the current line, disabling implicit output
０-９	push that number (０１２３４５６７８９) //KEYW 0 1 2 3 4 5 6 7 8 9
§	
‼	normalize
  N: 1 if the number isn't 0, otherwise 0
  S: 0 if the string is empty, otherwise 1
  a: move the [1;1] point to the top-left of the visible art
¼	
½	divide by 2
¾	
√	square root
  N: get the square root
    `９２√＊Ｕ` → 13
／	create an antidiagonal
  N: create a antidiagonal of that length
  S: create a antidiagonal of the characters of that string
  a: prepend each line with one less space than the last, the last line having 0 spaces
＼	create a diagonal
  N: create a diagonal of that length
  S: create a diagonal of the characters of that string
  a: prepend each line with one more space than the last, the first having 0 spaces
∑	join together
  A: join the array together
    `（（ab∙cd）（ef∙gh））∑` → "abcdefgh"
  N, S: join the stack until `（` or end into a string
∙	NOP / separator / space
  NOOP if both or no sides are ASCII
    `abc∙def┐` → "def"
  if ASCII is only on one side, pushes a space
    `abc∙×` → "a b c"
‽	if not / switch
  `‽false!｝` - if POP is falsy 
  `‽N］north｝S］south｝E］east｝west｝We're going ＊` - input [NSEW] and the output will expand the direction name and prepend "We're going "
‾	
⇵	reverse vertically
  N: ceiling divide by 2, storing the remainder
    `７⇵` → 4
  A: reverse the items
    `１２）hello（７world））⇵` → [[7,"world"], "hello", [1,2]]
  a: reverse vertically
：	duplicate ToS
  `la：＋` → "lala"
⌐	duplicate POP twice //KEYW triplicate
  `la⌐）∑` → "lalala"
；	swap top two stack items
  `４９；－` → 5
⟳	rotate clockwise w/o character changing
  a: rotate clockwise once
    `i∙h!∔⟳` → `hi¶!`
  aN: rotate clockwise that many times
  A, AN: rotate the items so that it looks rotated if printed
⤢	transpose / absolute value
  a: transpose
  N: absolute value
∔	add vertically / reverse subtract
  NN: reverse subtract
  SS: add the two together with a separating newline
  AS: add the string to the array
  SA: prepend the string to the arrays beginning
  AA: add the two arrays together
  aa: add the two vertically
ŗ	replace in a string with pop
“	
”	
■	
？	if/case. and `case` for numbers 0..x if followed by `］` and ended with `｝`
  ｝: if
    `？truthy!｝` pushes "truthy" if the input is truthy
  ］｝: `case` for numbers 0..x. first is default, next is 0, next - 1, next - 2, ect.<br>If only 2 blocks are used, this is basically if/else.
    `？truthy!］falsy｝` outputs "truthy" if the input is truthy
    `？not zero nor one］zero］one｝` self explanatory

↶	rotate anticlockwise
  a: rotate counter clockwise, rotating characters that make sense to be rotated
↷	rotate clockwise
  a: rotate clockwise, rotating characters that make sense to be rotated
  aN: rotate clockwise that many times
＠	get item
  AN, NA: push that item (1-indexed) from the array
  SN, SA: push that char (1-indexed) from the string
＃	execute as JS
    `"Hello, "+"JS!"＃` → "Hello, JS!"
％	modulo
  NN: modulo
    `８３％` → 2
！	
α	get the second to last argument used in a simpleFunction
    `７３÷１％α；－` → 2 (floor division implementation)
ω	get the last argument used in a simpleFunction
    `７３÷αω％ω÷－` → 2 (floor division implementation)

─	palindzomize vertically with 1 overlap
═	palindzomize vertically with 0 overlap
│	palindzomize horizontally with 1 overlap
║	palindzomize horizontally with 0 overlap
┼	quad-palindzomize with 1 overlap
╬	quad-palindzomize with 0 overlap
╫	quad-palindzomize with 1 overlap vertically and 0 horizontally
╪	quad-palindzomize with 0 overlap vertically and 1 horizontally
two of the same palindromizators next to each other disable character mirroring
if after a double-line there's a character with that as a single line, it's replaced by a remainder.
So ╫│ is vertical palindromization with overlap 1 and horizontal with overlap of the remainder



